\newpage
\appendix


\newpage
\section{Anforderungen}

\subsection{Anforderungen aus Kontextebene} \label{anfkontext}
\begin{table}[ht!]
  \begin{tabularx}{\textwidth}{@{}lXp{2cm}@{}}
      \toprule
      ID                & Anforderung & Quelle \\
      \midrule
      % Funktionale Anforderungen
      \textbf{K-FA-1}              &   Das System muss dem Nutzer Zugriff auf den digitalen Zwilling der Anlage gewähren.  & \textit{K-P-1}                \\
      \multicolumn{1}{r}{K-FA-1.1} &  Das Sytem muss dem Nutzer die aktuellen Messewerte in Echtzeit anzeigen.    & \textit{K-P-1.1}\\
      \multicolumn{1}{r}{K-FA-1.2} & Das System muss dem Nutzer die Verortung der Anlage ermöglichen. \\
      \multicolumn{1}{r}{K-FA-1.3} & Das System muss dem Nutzer prädiktive Informationen liefern.\\
      \multicolumn{1}{r}{K-FA-1.4} & Das System muss dem Nutzer die Reaktion auf kritische Zustände in Echtzeit ermöglichen.  & \textit{K-P-1.2}\\
      % Qualitative Anforderungen
      \textbf{K-QA-1}              & Die Architektur des Systems muss dem \ac{sa} die flexible Anpassung an Änderungen erlauben.     & \textit{K-P-2}                \\
      \textbf{K-QA-2}              & Die Architektur des Systems muss dem \ac{sa} die Einbindung neuer Anlagen erlauben.           & \textit{Auftraggeber}                \\
      \textbf{K-QA-3}              &  Die Architektur des System muss dem \ac{sa} die Einbindung von intelligenten Diensten erlauben.  & \textit{K-P-4.1} \\
      \textbf{K-QA-4}              &  Die Architektur des System muss dem \ac{sa} erlauben, das System um Funktionen zu erweitern.  & \textit{K-P-4.1} \\
      % Rahmenbedingungen
      \textbf{K-RA-1}              & Für die Umsetzung des Prototypen muss die SAP Leonardo IoT Foundation verwendet werden.       & \textit{K-P-4} \\
      \textbf{K-RA-2}              & Die Architektur des Systems muss mit \ac{rami} konform sein.      & \textit{K-P-3} \\
      \textbf{K-RA-3}              & Die Simulation muss die Eigenschaften einer Industrie-4.0-Komponente aufweisen.      & \textit{K-P-4.2} \\
      \addlinespace
      \bottomrule
  \end{tabularx}
  \caption{Anforderungen aus Kontextebene}
  \label{kontext_anforderungen}
\end{table}


\subsection{Lösung aus Kontextebene}
\begin{table}[H]
  \begin{tabularx}{\textwidth}{@{}lXp{2cm}@{}}
      \toprule
      ID                & Lösung & Quelle \\
      \midrule
      \textbf{K-L-1}              &   Intelligente Verwaltungsschale für die reale Anlage & \textit{K-P-1}                \\
      \multicolumn{1}{r}{K-L-1.1} &  Der Zustand und zugehörige Daten sollen jederzeit einsehbar sein & \textit{K-P-1.1}\\
      \multicolumn{1}{r}{K-L-1.2} & Der Zustand der Anlage soll bewertbar sein & \textit{K-P-1.2}\\
      \multicolumn{1}{r}{K-L-1.3} & kritische Zustandsveränderungen sollen unverzüglich gemeldet werden & \textit{K-P-1.3}\\
      \textbf{K-L-2}              & IT-Sicht des RAMI 4.0 und Industrie-4.0-Komponente           & \textit{K-P-3}                \\
      \textbf{K-L-3}              &  Prototypische Architekturvorlage für IoT-Projekte & \textit{K-P-3} \\
      \multicolumn{1}{r}{K-L-3.1} &  Messinstrument zur Simulation einer realen Anlage & \textit{K-P-4.2}\\
      \addlinespace
      \bottomrule
  \end{tabularx}
  \label{kontext_losung}
  \caption{Lösungen aus Kontextebene}
\end{table}

% Anforderungen Systemebene
\subsection{Anforderungen aus Systemebene} \label{anf_system}

%\begin{table}[ht!]
  \begin{tabularx}{\textwidth}{@{}lXp{2cm}@{}}
      \toprule
      ID                & Anforderung & Quelle \\
      \midrule
      \endhead
      % Funktionale Anforderungen
      \textbf{S-FA-1} \label{sfa1}             &  Das Messinstrument muss min. alle 5 Sekunden Umgebungsdaten erfassen und verarbeiten können.   &  \textit{Kontext}     \\
      \multicolumn{1}{r}{S-FA-1.1} &   Das Messinstrument muss die Messungen nach der Erfassung kommunizieren können. & \textit{\ac{i40}}\\
      \multicolumn{1}{r}{S-FA-1.2} &   Das Messinstrument muss als Entität in einem übergeordneten IT-System vorliegen. & \textit{\ac{i40}}\\
      \textbf{S-FA-2}              &   Der Prototyp muss das Messinstrument virtuell als Anlage beschreiben können. & \textit{\ac{i40}}        \\
      \multicolumn{1}{r}{S-FA-2.1} &   Der Prototyp muss das Messinstrument eindeutig per \textit{URI} identifizieren können.  & \textit{\ac{i40}}\\
      \multicolumn{1}{r}{S-FA-2.2} &   Der Prototyp muss das Messinstrument eindeutig per Koordinaten verorten können.  & \textit{\ac{i40}}\\
      \multicolumn{1}{r}{S-FA-2.3} & Der Prototyp muss die Daten (Messwerte und Eigenschaften) der virtuellen Repräsentation halten.  & \textit{\ac{i40}} \\
      \multicolumn{1}{r}{S-FA-2.4} & Der Prototyp muss die Grenzüberschreitung der empfangenen Daten erkennen. &  \textit{Kontext}\\
      \multicolumn{1}{r}{S-FA-2.5} & Der Prototyp muss die empfangenen Daten kategorisieren. &  \textit{Kontext}\\
      \multicolumn{1}{r}{S-FA-2.6} & Der Prototyp muss eine Benachrichtiungs-SMS versenden.  &  \textit{Kontext}\\
      \multicolumn{1}{r}{S-FA-2.7} & Der Prototyp muss Ereignisse generieren.  &  \textit{Kontext}\\
      \multicolumn{1}{r}{S-FA-2.8} & Der Prototyp muss die Anlage an eine Anwendung übergeben. &  \textit{Kontext} \\
      \textbf{S-FA-3}              &  Der Prototyp muss dem Nutzer eine Benutzerschnittstelle zur Verfügung stellen.    & \textit{Kontext}  \\
      \multicolumn{1}{r}{S-FA-3.1} &  Die Benutzerschnittstelle muss alle Anlagen auf einer Karte verorten. \\
      \multicolumn{1}{r}{S-FA-3.2} &  Die Benutzerschnittstelle muss die schnelle Bewertung des Zustands ermöglichen. \\
      \multicolumn{1}{r}{S-FA-3.3} &  Die Benutzerschnittstelle muss alle Messwerte auflisten. \\
      \multicolumn{1}{r}{S-FA-3.4} &  Die Benutzerschnittstelle muss die Messwerte visualisieren. \\
      \textbf{S-QA-1}              & Die Benutzerschnittstelle muss intuitiv sein.   \\
      % Qualitative Anforderungen
      \textbf{S-QA-2}              & Die Architektur des Systems muss dem \ac{sa} die horizontale Integration der Anlage ermöglichen.   & \textit{RAMI 4.0} \\
      \textbf{S-QA-3}              &  Die Kommunikation muss nach einem einheitlichen semantischen Modell erfolgen.  & \textit{\ac{i40}} \\
      \textbf{S-QA-3}              &  Der Prototyp muss sicher sein.  & \textit{\ac{i40}} \\
      \multicolumn{1}{r}{S-QA-3.1}              &  Der Prototyp muss die Verfügbarkeit der Informationen gewährleisten.  & \textit{\ac{i40}} \\
      \multicolumn{1}{r}{S-QA-3.2}              &  Der Prototyp muss die Vertraulichkeit der Informationen gewährleisten.  & \textit{\ac{i40}} \\
      \multicolumn{1}{r}{S-QA-3.3}              &  Der Prototyp muss die Integrität der Informationen gewährleisten. & \textit{\ac{i40}} \\
      \addlinespace
      \bottomrule
      \caption{Anforderungen aus Systemebene}
      \label{system_anforderungen}
  \end{tabularx}


   
\section{Quelltext}

\subsection{Python Skript: test\_data.py}

\begin{lstlisting}
# Skript zum Erzeugen und Lesen von Sensordaten

import grovepi
from grovepi import *
import math
import random
import sys
from gpiozero import DigitalInputDevice
from time import sleep
from send_test_data import send_data
import send_test_data as send
import json
# Wind/Anemometer
count = 0
radius_cm = 2.0        # Radius of the anemometer
interval = 5        # How often to report speed
ADJUSTMENT = 1.18    # Adjustment for weight of cups
CM_IN_A_KM = 100000.0
CM_IN_METER = 1000.0
SECS_IN_AN_HOUR = 3600
# Luftdichte
airtight = 0
#Temperatur und Luftfeuchtigkeit

temp_hum_sensor = 4  # digital port 4.

blue = 0    # The Blue colored sensor.
white = 1   # The White colored sensor.

# Collection fuer Luftdruckwerte
pressureCollection = [1002, 1004, 1005, 1006, 1008, 1010, 1011, 1012, 1013]
 
def simulatePressure():
    global pressureCollection
    pressure = random.choice(pressureCollection)
    print("Pressure: ", pressure, "hpa")
    return pressure

def calculate_speed_kmh(time_sec):
    global count
    circumference_cm = (2 * math.pi) * radius_cm
    rotations = count / 2.0

    dist_km = (circumference_cm * rotations) / CM_IN_A_KM
    km_per_sec = dist_km / time_sec
    km_per_hour = km_per_sec * SECS_IN_AN_HOUR
    speed = km_per_hour * ADJUSTMENT

    return speed

def spin():
    global count
    count = count + 1
    print(count)

# Gpio4 auf dem GrovePi+
wind_speed_sensor = DigitalInputDevice(4)
wind_speed_sensor.when_activated = spin

def readSensors():
    global count
    print("Method Started")
    while True:
        count = 0
        sleep(interval)
        [temperature, humidity] = grovepi.dht(temp_hum_sensor, blue)
        pressure = simulatePressure()
        wind_speed = calculate_speed_kmh(interval)
        airtight = calculateAirtight(temperature, pressure)

# Konvertiere sensorData zu String fuer Sending request
        sensorData = {
            "temperature": str(temperature),
            "wind_speed": str(wind_speed),
            "pressure": str(pressure),
            "humidity": str(humidity),
            "airtight": str(airtight)
        }
        print("SensorData", sensorData)
        print("SensorDataTypebeforesending", type(sensorData))

        send.send_data(sensorData)
        return sensorData

# Luftdichte berechnen
def calculateAirtight(temp_cel, pressure):

    temp_cel = temp_cel
    temp_kel = (temp_cel + 273.15)
    p = pressure
    r = 287.05
    print("pressure", p)
    print("r", r)
    print("temp_kel", temp_kel)
    print("temp_cel", temp_cel)

    airtight = (p * 100) / (r * temp_kel)
    airtight = round(airtight, 2)

    print("Die Luftdichte bei ", temp_cel, "Grad Celcius und ", p, "hpA betraegt ", airtight, "kg/m**3")
    return airtight
while True:
    readSensors()
\end{lstlisting}

\subsection{Python Skript: send\_test\_data.py}

\begin{lstlisting}
# Daten senden via REST Edge Gateway
# CURL-Command
# curl -v -H "Content-Type: application/json" -d "{ \"capabilityAlternateId\": \"1\", \"sensorTypeAlternateId\": \"0\", \"measures\": [{\"temperature\": \"25\"}] }"
# http://<IP_GW_EDGE>:<PORT_GW_EDGE>/measures/<DEVICE_ALTERNATE_ID>

from grovepi import *
import sys
import requests
import json
import time
import math
from datetime import datetime

# Variablen fur Verbindung mit IOT-Services

deviceAlternateId = '60b373db-d6dc-4696-b916-aefec6d95cd0'  
sensorAlternateId = 'root'  
capabilityAlternateId = '1234'  # wind_1
tenant = 'https://5075f8b9-866e-4a4b-82f8-74687b72f1ab.eu10.cp.iot.sap/iot/gateway/rest/measures/'  # the IoT Service Host Name

postAddress = ('http://192.168.178.52:8699/measures/' + deviceAlternateId)
postAddressCommand = ('http://192.168.178.52:8699/commands/' + deviceAlternateId)
print('Posting to:', postAddress)

led = 3 # Digital Port 3 
pinMode(led, "OUTPUT")
time.sleep(1)

# Methode zum Erhalten von Commands

def get_command():
    print("Sending Command Started")

    try:

        headers = {'content-type': 'application/json'}
        r = requests.get(postAddressCommand, deviceAlternateId)

        responseCode = r.status_code

        print("==> HTTP Response: %d" % responseCode)

        result = r.text
        print(result)

        print(type(result))
        result = result.encode('utf8')
        print(type(result))
        print(result)

    except IOError:
        print("Error")

    ledtrue = "true"

    if ledtrue in result:
        digitalWrite(led, 1)     # Send HIGH to switch on LED
        print("LED True!")
        time.sleep(4)
        digitalWrite(led, 0)     # Send HIGH to switch on LED
        print("LED Off")
        time.sleep(1)

# Methode zum Senden von Sensordaten an die Cloud
def send_data(sensorData):
    print("Sending Method Started")
    print("SensorDataType", type(sensorData))
    try:
        print("")
        print("============================================")
        print("Reading sensor data ...")

        bodyJson = {
            "capabilityAlternateId": capabilityAlternateId,
            "sensorAlternateId": sensorAlternateId,
            # "measures": [{"temperature": sensorData[0]}, {"wind_speed": sensorData[1]}, {"pressure": sensorData[2]}, {"humidity": sensorData[3]}]
            "measures": [{"temperature": sensorData["temperature"]}, {"wind_speed": sensorData["wind_speed"]}, {"pressure": sensorData["pressure"]}, {"humidity": sensorData["humidity"]}, {"airtight": sensorData["airtight"]}]
        }

        data = json.dumps(bodyJson)
        headers = {'content-type': 'application/json'}
        r = requests.post(postAddress, data=data, headers=headers)
        responseCode = r.status_code
        print(str(bodyJson))
        print("==> HTTP Response: %d" % responseCode)

    except IOError:
        print("Error")

    get_command()
\end{lstlisting}
\clearpage
\subsection{Python Skript: AWS\_Flask.py}
\begin{lstlisting}
import boto3
from flask import Flask
from flask import request
import os
import time
from sap.cf_logging import flask_logging
import logging

app = Flask(__name__)
flask_logging.init(app, logging.INFO)
logger = logging.getLogger('cf.dev.beta.bla.aws_sms')

cf_port = os.getenv("PORT")

time_last_sms = 0
time_curr = 0
diff_min = 0

@app.route('/')
def input():
    logger.info('MOIN')
    return("Ok..")

@app.route('/postjson', methods=['POST'])
def postJsonHandler():
    global time_curr
    global time_last_sms
    global diff_min

    time_curr = int(time.time()) # aktuelle zeit in unix epoch timestamp
    diff_min = round(((time_curr - time_last_sms) / 100), 0) # letzter sendezeitpunkt minus aktuelle zeit

    logger.info("last sms sent: " + str(time_last_sms))
    logger.info("time_curr: " + str(time_curr))
    logger.info("diff_min: " + str(diff_min))

    if diff_min < 0 or diff_min > 2:
      #print(request.is_json)
      content = request.get_json()

      #print(content)
      phone = content['phone']
      message = content['message']
      #print("{}".format(phone))  # you can comment it out
      #print("{}".format(message))  # you can comment it out

      # Create an SNS client
      client = boto3.client("sns",
                            aws_access_key_id="AKIAI44Y3******",
                            aws_secret_access_key="EXKQJR2D9*********",
                            region_name="eu-west-1"
                            )

      # Send your sms message.
      logger.info('sending sms ...')
      client.publish(
          PhoneNumber="{}".format(phone),
          Message="{}".format(message)
      )
      time_last_sms = time_curr # zeitpunkt zuletzt gesendet auf aktuellen sendezeitpunkt setzen
      return 'SMS alert sent :)'
    return 'Last SMS sent before 2min intervall.'

if __name__ == '__main__':
    if cf_port is None:
        app.run(host='0.0.0.0', port=5000, debug=True)
    else:
        app.run(host='0.0.0.0', port=int(cf_port), debug=True)
\end{lstlisting}

\clearpage
\subsection{API-Anfragen für Aktionen}

\begin{lstlisting}
# Aktion Event_Orkan
POST to Destination Standard_EventType: https://events-sap.cfapps.eu10.hana.ondemand.com/ES/EventType/com.sap.appiot.eventtypes:StandardEventType/v1/Events
{
	"BusinessTimestamp": "${event.time}",
	"Type": "Alert",
	"EventInfo": "Alert on Wind_Speed",
	"EventStatus": "Open",
	"EventSeverity": 1,
	"EventCode": null,
	"EventSource": null,
	"ThingId": "${thing.id}",
	"ThingProperty": "wind_speed",
	"ExternalId": "Orkan"
}
# Aktion Event_Sturm
 POST to Destination Standard_EventType: https://events-sap.cfapps.eu10.hana.ondemand.com/ES/EventType/com.sap.appiot.eventtypes:StandardEventType/v1/Events
{
	"BusinessTimestamp": "${event.time}",
	"Type": "Alert",
	"EventInfo": "Alert on Wind_Speed",
	"EventStatus": "Open",
	"EventSeverity": 2,
	"EventCode": null,
	"EventSource": null,
	"ThingId": "${thing.id}",
	"ThingProperty": "wind_speed",
	"ExternalId": "Sturm"
}
# Aktion Event_Temperature
POST to Destination Standard_EventType: https://events-sap.cfapps.eu10.hana.ondemand.com/ES/EventType/com.sap.appiot.eventtypes:StandardEventType/v1/Events
{
	"BusinessTimestamp": "${event.time}",
	"Type": "Alert",
	"EventInfo": "Alert on engine temperature",
	"EventStatus": "Open",
	"EventSeverity": 1,
	"EventCode": null,
	"EventSource": null,
	"ThingId": "${thing.id}",
	"ThingProperty": "temperature",
	"ExternalId": "Kritische Temperatur"
}
\end{lstlisting}

